"""
Copyright (c) 2019-2024 MemryX Inc.
All Rights Reserved.

============
Information:
============
File Name: dfp_inspect.py

============
Description:
============
API for DFP metadata inspection.
This does *NOT* decrypt anything, so it
is safe to give to end users.

========
Authors:
========
* BlackNeckBeard, the Internet Pirate (Tim)

"""

import argparse
import struct
from pathlib import Path
from io import BytesIO
from pprint import pprint
import json
from utilities.mxpack import MxPackDecode




###############################################################################
def dfp_inspect(dfp, printout=False):
    """
    DFP inspect is utility that parses the metadata from a given dfp file/object, and returns
    a Python dict of the information.

    *Currently, it returns the following DFP information:*

    * **DFP**
        * Version
        * The compilation date and time
        * The target number of chips
        * The target architecture generation
    * **The file names of the compiled models**
    * **The active input and output ports configurations**

    Parameters
    ----------
        dfp: string or bytearray
            Either a loaded dfp object (bytearray), or path to a .dfp file (string)

        printout: bool
            If True, print the parsed metadata to terminal. (default: False)

    Returns
    -------

        metadata: dict
            A dictionary of the DFP information

    Examples
    --------
    .. code-block:: python

        from memryx.utilities.dfp_inspect import dfp_inspect

        dfp_inspect(your_dfp)

    """

    dfp_bytes = None
    if isinstance(dfp, (str, Path)):
        if not dfp.endswith('.dfp'):
            raise Exception(f"Input file: {dfp} is not a .dfp file generated by the NeuralCompiler")
        try:
            dfp_bytes = open(str(dfp), 'rb')
        except:
            raise Exception(f"Error opening file {dfp}")
    elif type(dfp) is bytearray:
        dfp_bytes = BytesIO(dfp)
    else:
        raise Exception(f"dfp argument is not type str or bytearray, it is type={type(dfp)}")

    possible_version_info = int.from_bytes(dfp_bytes.read(8), byteorder='little')
    if possible_version_info == 3:
        metadata = __decode_v3(dfp_bytes)
    elif possible_version_info == 4:
        metadata = __decode_v4(dfp_bytes)
    elif possible_version_info == 5:
        metadata = __decode_v5(dfp_bytes)
    elif possible_version_info == 6:
        metadata = __decode_v6(dfp_bytes)
    else:
        metadata = __decode_legacy(dfp_bytes)

    # rewind (in case it's a bytearray they wanna use again)
    dfp_bytes.seek(0)

    # print?
    if printout:
        __pretty_print(metadata)

    return metadata

###############################################################################
def __pretty_print(meta):

    # Define colors
    orange = "\033[38;2;255;153;51m"
    blue = "\033[38;2;0;153;255m"
    green = "\033[38;2;102;255;102m"
    yellow= "\033[38;2;255;255;51m"
    gray= "\033[38;2;150;150;150m"
    BOLD = '\033[1m'
    d = "\033[0m"

    print("\n╔"+"═"*38+"╗\n"+
              "║             DFP Inspect              ║\n"+
              "║  Copyright (c) 2019-2024 MemryX Inc. ║\n"+
              "╚"+"═"*38+"╝\n")

    print("═"*40)
    print(blue+BOLD+"DFP Info:"+d)
    if meta['dfp_version'] == "legacy":
        print(f"DFP format:        {meta['dfp_version']}")
    else:
        print(f"DFP format:        v{meta['dfp_version']}")

    if 'compiler_version' in meta:
        print(f"Compiler version:  {meta['compiler_version']}")

    if 'compile_time' in meta:
        print(f"Compile Time:      {meta['compile_time']}")

    if 'simulator_dfp_size' in meta:
        print(f"Simulator DFP:     {round(meta['simulator_dfp_size'],2)} MB")

    if 'hardware_dfp_size' in meta:
        print(f"Hardware DFP:      {round(meta['hardware_dfp_size'],2)} MB")

    print(f"MXA Generation:    {meta['mxa_gen']}")
    print(f"Number of MXAs:    {meta['num_mxas']}")
    print("─"*40)
    print(blue+BOLD+"Models Info:"+d)

    if 'models' in meta:
        for i, m in enumerate(meta['models']):
            print(f"Model {i:2d}: {m}")

    print("─"*40)
    print(blue+BOLD+"Active Input Ports Configs:"+d)
    for i in range(meta['num_inports']):
        if meta['input_ports'][i]['active']:
            print(f"Port {i}:  ", end='')
            pprint(meta['input_ports'][i])
        # else:
        #     print(f"Port {i}:  inactive")
    print("─"*40)
    print(blue+BOLD+"Active Output Ports Configs:"+d)
    for i in range(meta['num_outports']):
        if meta['output_ports'][i]['active']:
            print(f"Port {i}:  ", end='')
            pprint(meta['output_ports'][i])
        # else:
        #     print(f"Port {i}:  inactive")

    print("═"*40)


###############################################################################
def __decode_legacy(f):

    meta = {"dfp_version": "legacy"}
    gen_towers = int.from_bytes(f.read(1), byteorder='little')
    if (gen_towers & 0x0F) == 4:
        gen = "Cascade+"
    elif (gen_towers & 0x0F) == 3:
        gen = "Cascade"
    elif (gen_towers & 0x0F) == 2:
        gen = "Barton"
    else:
        raise Exception(f"Unknown MXA generation {gen_towers & 0x0F} detected!")
    towers = (gen_towers & 0xF0) >> 4
    mpus = int.from_bytes(f.read(1), byteorder='little')
    frequency = int.from_bytes(f.read(2), byteorder='little')

    meta['mxa_gen'] = gen
    meta['num_mxas'] = mpus

    meta['sim_info'] = {'towers': towers, 'frequency': frequency}

    # port info
    inport_info_dict = {}
    outport_info_dict = {}
    num_inports = int.from_bytes(f.read(1), "little")
    num_outports = int.from_bytes(f.read(1), "little")
    meta['num_inports'] = num_inports
    meta['num_outports'] = num_outports
    # INPORTS
    # ==============================================================
    for i in range(num_inports):
        port_idx_and_status = int.from_bytes(f.read(1), "little")
        port_set = int.from_bytes(f.read(1), "little")
        fmt = int.from_bytes(f.read(1), "little")
        range_en = int.from_bytes(f.read(1), "little")
        range_sh = struct.unpack('<f', bytearray(f.read(4)))[0]
        range_sc = struct.unpack('<f', bytearray(f.read(4)))[0]
        row = int.from_bytes(f.read(2), "little")
        col = int.from_bytes(f.read(2), "little")
        z = int.from_bytes(f.read(2), "little")
        ch = int.from_bytes(f.read(2), "little")
        # active port
        if (port_idx_and_status & 0x0080) == 0x80:
            # port index + status
            port = port_idx_and_status & 0x007F
            inport_info_dict[port] = {"active": True}
            inport_info_dict[port]['set'] = port_set
            # data format
            if fmt == 0:
                inport_info_dict[port]['format'] = "float" # actually GBF80
            elif fmt == 1:
                inport_info_dict[port]['format'] = "rgb888"
            elif fmt == 2:
                inport_info_dict[port]['format'] = "rgb565"
            elif fmt == 3:
                inport_info_dict[port]['format'] = "yuv422"
            elif fmt == 4:
                inport_info_dict[port]['format'] = "yuy2"
            elif fmt == 5:
                inport_info_dict[port]['format'] = "float" # actually BF16
            else:
                inport_info_dict[port]['format'] = "unknown: " + str(fmt)
            # range info
            if range_en == 1:
                inport_info_dict[port]['data_range_enabled'] = True
            else:
                inport_info_dict[port]['data_range_enabled'] = False
            inport_info_dict[port]['data_range_shift'] = range_sh
            inport_info_dict[port]['data_range_scale'] = range_sc
            # shapes
            inport_info_dict[port]['shape'] = [row, col, z, ch]
        else:
            # inactive port
            port = port_idx_and_status
            inport_info_dict[port] = {"active": False, "set": 0, "format": "float",
                    "data_range_enabled": False, "data_range_shift": 0, "data_range_scale": 0,
                    "shape": [0, 0, 0, 0] }

    # OUTPORTS
    # ==============================================================
    for i in range(num_outports):
        port_idx_and_status = int.from_bytes(f.read(1), "little")
        fmt = int.from_bytes(f.read(1), "little")
        row = int.from_bytes(f.read(2), "little")
        col = int.from_bytes(f.read(2), "little")
        z = int.from_bytes(f.read(2), "little")
        ch = int.from_bytes(f.read(2), "little")
        # active port
        if (port_idx_and_status & 0x0080) == 0x80:
            # port index + status
            port = port_idx_and_status & 0x007F
            outport_info_dict[port] = {"active": True}
            # data format
            if fmt == 0:
                outport_info_dict[port]['format'] = "float" # actually GBF80
            elif fmt == 1:
                outport_info_dict[port]['format'] = "float" # actually BF16
            else:
                outport_info_dict[port]['format'] = "unknown: " + str(fmt)
            # shapes
            outport_info_dict[port]['shape'] = [row, col, z, ch]
        else:
            # inactive port
            port = port_idx_and_status
            outport_info_dict[port] = {"active": False, "format": "float", "shape": [0, 0, 0, 0] }

    meta['input_ports'] = inport_info_dict
    meta['output_ports'] = outport_info_dict

    return meta

###############################################################################
def __decode_v3(f):

    meta = {"dfp_version": "3"}

    total_sim_bytes = int.from_bytes(f.read(8), byteorder='little')
    gen_towers = int.from_bytes(f.read(1), byteorder='little')
    if (gen_towers & 0x0F) == 4:
        gen = "Cascade+"
    elif (gen_towers & 0x0F) == 3:
        gen = "Cascade"
    elif (gen_towers & 0x0F) == 2:
        gen = "Barton"
    else:
        raise Exception(f"Unknown MXA generation {gen_towers & 0x0F} detected!")

    towers = (gen_towers & 0xF0) >> 4
    mpus = int.from_bytes(f.read(1), byteorder='little')
    frequency = int.from_bytes(f.read(2), byteorder='little')
    num_inports = int.from_bytes(f.read(1), "little")
    num_outports = int.from_bytes(f.read(1), "little")
    meta['num_inports'] = num_inports
    meta['num_outports'] = num_outports

    meta['sim_info'] = {'towers': towers, 'frequency': frequency}

    meta['mxa_gen'] = gen
    meta['num_mxas'] = mpus
    inport_info_dict = {}
    outport_info_dict = {}

    # INPORTS
    # ==============================================================
    for i in range(num_inports):
        port_idx_and_status = int.from_bytes(f.read(1), "little")
        # if inport is enabled
        if (port_idx_and_status & 0x0080) == 0x80:
            port_set = int.from_bytes(f.read(1), "little")
            fmt = int.from_bytes(f.read(1), "little")
            range_en = int.from_bytes(f.read(1), "little")
            range_sh = struct.unpack('<f', bytearray(f.read(4)))[0]
            range_sc = struct.unpack('<f', bytearray(f.read(4)))[0]
            row = int.from_bytes(f.read(2), "little")
            col = int.from_bytes(f.read(2), "little")
            z = int.from_bytes(f.read(2), "little")
            ch = int.from_bytes(f.read(2), "little")

            # set the data dict
            port = port_idx_and_status & 0x007F
            inport_info_dict[port] = {"active": True}
            inport_info_dict[port]['set'] = port_set
            if fmt == 0:
                inport_info_dict[port]['format'] = "float" # actually GBF80
            elif fmt == 1:
                inport_info_dict[port]['format'] = "rgb888"
            elif fmt == 2:
                inport_info_dict[port]['format'] = "rgb565"
            elif fmt == 3:
                inport_info_dict[port]['format'] = "yuv422"
            elif fmt == 4:
                inport_info_dict[port]['format'] = "yuy2"
            elif fmt == 5:
                inport_info_dict[port]['format'] = "float" # actually BF16
            else:
                inport_info_dict[port]['format'] = "unknown: " + str(fmt)
            # range info
            if range_en == 1:
                inport_info_dict[port]['data_range_enabled'] = True
            else:
                inport_info_dict[port]['data_range_enabled'] = False
            inport_info_dict[port]['data_range_shift'] = range_sh
            inport_info_dict[port]['data_range_scale'] = range_sc
            # shapes
            inport_info_dict[port]['shape'] = [row, col, z, ch]
        else:
            # inactive port
            port = port_idx_and_status
            inport_info_dict[port] = {"active": False, "set": 0, "format": "float",
                    "data_range_enabled": False, "data_range_shift": 0, "data_range_scale": 0,
                    "shape": [0, 0, 0, 0] }

    # OUTPORTS
    # ==============================================================
    for i in range(num_outports):
        port_idx_and_status = int.from_bytes(f.read(1), "little")
        if (port_idx_and_status & 0x0080) == 0x80:
            port_set = int.from_bytes(f.read(1), "little")
            fmt = int.from_bytes(f.read(1), "little")
            row = int.from_bytes(f.read(2), "little")
            col = int.from_bytes(f.read(2), "little")
            z = int.from_bytes(f.read(2), "little")
            ch = int.from_bytes(f.read(2), "little")

            hpoc_eni = int.from_bytes(f.read(1), "little")
            # hpoc en?
            if hpoc_eni == 1:
                hpoc_en = True
                # hpoc list length + data
                hpoc_ch_list_len = int.from_bytes(f.read(2), "little")
                hpoc_ch_list = []
                for _ in range(hpoc_ch_list_len):
                    hpoc_ch_list.append(int.from_bytes(f.read(2), "little"))
            else:
                # hpoc disabled!
                hpoc_en = False
                hpoc_ch_list_len = 0
                hpoc_ch_list = []

            # port index + status
            port = port_idx_and_status & 0x007F
            outport_info_dict[port] = {"active": True}
            # port set
            outport_info_dict[port]['set'] = port_set
            # data format
            if fmt == 0:
                outport_info_dict[port]['format'] = "float" # actually GBF80
            elif fmt == 1:
                outport_info_dict[port]['format'] = "float" # actually BF16
            else:
                outport_info_dict[port]['format'] = "unknown: " + str(fmt)
            # shapes
            outport_info_dict[port]['shape'] = [row, col, z, ch]

            # hpoc info
            outport_info_dict[port]['hpoc_enabled'] = hpoc_en
            outport_info_dict[port]['hpoc_list'] = hpoc_ch_list
        else:
            # inactive port
            port = port_idx_and_status
            outport_info_dict[port] = {"active": False, "set": 0, "format": "float",
                    "shape": [0, 0, 0, 0], "hpoc_enabled": False, "hpoc_list": [] }


    meta['input_ports'] = inport_info_dict
    meta['output_ports'] = outport_info_dict

    return meta


###############################################################################
def __decode_v4(f):

    meta = {"dfp_version": "4"}

    total_sim_bytes = int.from_bytes(f.read(8), byteorder='little')
    meta['simulator_dfp_size'] = float(total_sim_bytes / 1000000)

    # compile date/time
    numtimebytes = int.from_bytes(f.read(1), byteorder='little')
    meta['compile_time'] = str(f.read(numtimebytes), 'ascii')

    # model names
    total_model_str_bytes = int.from_bytes(f.read(4), byteorder='little')
    total_num_models = int.from_bytes(f.read(1), byteorder='little')
    meta['models'] = []
    for i in range(total_num_models):
        stringleng = int.from_bytes(f.read(2), byteorder='little')
        meta['models'].append(str(f.read(stringleng), 'utf-8'))


    gen_towers = int.from_bytes(f.read(1), byteorder='little')
    if (gen_towers & 0x0F) == 4:
        gen = "Cascade+"
    elif (gen_towers & 0x0F) == 3:
        gen = "Cascade"
    elif (gen_towers & 0x0F) == 2:
        gen = "Barton"
    else:
        raise Exception(f"Unknown MXA generation {gen_towers & 0x0F} detected!")

    towers = (gen_towers & 0xF0) >> 4
    mpus = int.from_bytes(f.read(1), byteorder='little')
    frequency = int.from_bytes(f.read(2), byteorder='little')
    num_inports = int.from_bytes(f.read(1), "little")
    num_outports = int.from_bytes(f.read(1), "little")
    meta['num_inports'] = num_inports
    meta['num_outports'] = num_outports

    meta['sim_info'] = {'towers': towers, 'frequency': frequency}

    meta['mxa_gen'] = gen
    meta['num_mxas'] = mpus
    inport_info_dict = {}
    outport_info_dict = {}

    # INPORTS
    # ==============================================================
    for i in range(num_inports):
        port_idx_and_status = int.from_bytes(f.read(1), "little")
        # if inport is enabled
        if (port_idx_and_status & 0x0080) == 0x80:
            port_set = int.from_bytes(f.read(1), "little")
            mpu_id = int.from_bytes(f.read(1), "little")
            model_index = int.from_bytes(f.read(1), "little")
            layer_name_leng = int.from_bytes(f.read(2), "little")
            layer_name = str(f.read(layer_name_leng), 'utf-8')
            fmt = int.from_bytes(f.read(1), "little")
            range_en = int.from_bytes(f.read(1), "little")
            range_sh = struct.unpack('<f', bytearray(f.read(4)))[0]
            range_sc = struct.unpack('<f', bytearray(f.read(4)))[0]
            row = int.from_bytes(f.read(2), "little")
            col = int.from_bytes(f.read(2), "little")
            z = int.from_bytes(f.read(2), "little")
            ch = int.from_bytes(f.read(2), "little")

            # set the data dict
            port = port_idx_and_status & 0x007F
            inport_info_dict[port] = {"active": True}
            inport_info_dict[port]['mxa_id'] = mpu_id
            inport_info_dict[port]['model_index'] = model_index
            inport_info_dict[port]['layer_name'] = layer_name
            inport_info_dict[port]['set'] = port_set
            if fmt == 0:
                inport_info_dict[port]['format'] = "float" # actually GBF80
            elif fmt == 1:
                inport_info_dict[port]['format'] = "rgb888"
            elif fmt == 2:
                inport_info_dict[port]['format'] = "rgb565"
            elif fmt == 3:
                inport_info_dict[port]['format'] = "yuv422"
            elif fmt == 4:
                inport_info_dict[port]['format'] = "float" # actually BF16
            elif fmt == 5:
                inport_info_dict[port]['format'] = "float" # actually FP32
            elif fmt == 6:
                inport_info_dict[port]['format'] = "yuy2"
            else:
                inport_info_dict[port]['format'] = "unknown: " + str(fmt)
            # range info
            if range_en == 1:
                inport_info_dict[port]['data_range_enabled'] = True
            else:
                inport_info_dict[port]['data_range_enabled'] = False
            inport_info_dict[port]['data_range_shift'] = range_sh
            inport_info_dict[port]['data_range_scale'] = range_sc
            # shapes
            inport_info_dict[port]['shape'] = [row, col, z, ch]
        else:
            # inactive port
            port = port_idx_and_status
            inport_info_dict[port] = {"active": False, "set": 0, "mxa_id": -1,
                    "model_index": -1, "layer_name": "", "format": "float",
                    "data_range_enabled": False, "data_range_shift": 0, "data_range_scale": 0,
                    "shape": [0, 0, 0, 0] }

    # OUTPORTS
    # ==============================================================
    for i in range(num_outports):
        port_idx_and_status = int.from_bytes(f.read(1), "little")
        if (port_idx_and_status & 0x0080) == 0x80:
            port_set = int.from_bytes(f.read(1), "little")
            mpu_id = int.from_bytes(f.read(1), "little")
            model_index = int.from_bytes(f.read(1), "little")
            layer_name_leng = int.from_bytes(f.read(2), "little")
            layer_name = str(f.read(layer_name_leng), 'utf-8')
            fmt = int.from_bytes(f.read(1), "little")
            row = int.from_bytes(f.read(2), "little")
            col = int.from_bytes(f.read(2), "little")
            z = int.from_bytes(f.read(2), "little")
            ch = int.from_bytes(f.read(2), "little")

            hpoc_eni = int.from_bytes(f.read(1), "little")
            # hpoc en?
            if hpoc_eni == 1:
                hpoc_en = True
                # hpoc list length + data
                hpoc_ch_list_len = int.from_bytes(f.read(2), "little")
                hpoc_ch_list = []
                for _ in range(hpoc_ch_list_len):
                    hpoc_ch_list.append(int.from_bytes(f.read(2), "little"))
            else:
                # hpoc disabled!
                hpoc_en = False
                hpoc_ch_list_len = 0
                hpoc_ch_list = []

            # port index + status
            port = port_idx_and_status & 0x007F
            outport_info_dict[port] = {"active": True}
            outport_info_dict[port]['mxa_id'] = mpu_id
            outport_info_dict[port]['model_index'] = model_index
            outport_info_dict[port]['layer_name'] = layer_name
            # port set
            outport_info_dict[port]['set'] = port_set
            # data format
            if fmt == 0:
                outport_info_dict[port]['format'] = "float" # actually GBF80
            elif fmt == 4:
                outport_info_dict[port]['format'] = "float" # actually BF16
            elif fmt == 5:
                outport_info_dict[port]['format'] = "float" # actually FP32
            else:
                outport_info_dict[port]['format'] = "unknown: " + str(fmt)
            # shapes
            outport_info_dict[port]['shape'] = [row, col, z, ch]

            # hpoc info
            outport_info_dict[port]['hpoc_enabled'] = hpoc_en
            outport_info_dict[port]['hpoc_list'] = hpoc_ch_list
        else:
            # inactive port
            port = port_idx_and_status
            outport_info_dict[port] = {"active": False, "set": 0, "mxa_id": -1,
                    "model_index": -1, "layer_name": "", "format": "float",
                    "shape": [0, 0, 0, 0], "hpoc_enabled": False, "hpoc_list": [] }

    meta['input_ports'] = inport_info_dict
    meta['output_ports'] = outport_info_dict

    # return to start and skip to hw dfp
    f.seek(0)
    f.seek(16, 1)
    f.seek(total_sim_bytes, 1)
    hw_data_size = int.from_bytes(f.read(8), "little")
    meta['hardware_dfp_size'] = float(hw_data_size / 1000000)

    return meta


###############################################################################
def __decode_v5(f):

    meta = {"dfp_version": "5"}

    total_sim_bytes = int.from_bytes(f.read(8), byteorder='little')
    meta['simulator_dfp_size'] = float(total_sim_bytes / 1000000)

    # compile date/time
    numtimebytes = int.from_bytes(f.read(1), byteorder='little')
    meta['compile_time'] = str(f.read(numtimebytes), 'ascii')

    # model names
    total_model_str_bytes = int.from_bytes(f.read(4), byteorder='little')
    total_num_models = int.from_bytes(f.read(1), byteorder='little')
    meta['models'] = []
    for i in range(total_num_models):
        stringleng = int.from_bytes(f.read(2), byteorder='little')
        meta['models'].append(str(f.read(stringleng), 'utf-8'))

    # compiler version
    ver_str_len = int.from_bytes(f.read(1), byteorder='little')
    meta['compiler_version'] = str(f.read(ver_str_len), 'ascii')

    # compiler args
    args_len = int.from_bytes(f.read(4), byteorder='little')
    args_str = str(f.read(args_len), 'utf-8')
    meta['compiler_args'] = json.loads(args_str)


    gen_towers = int.from_bytes(f.read(1), byteorder='little')
    if (gen_towers & 0x0F) == 4:
        gen = "Cascade+"
    elif (gen_towers & 0x0F) == 3:
        gen = "Cascade"
    elif (gen_towers & 0x0F) == 2:
        gen = "Barton"
    else:
        raise Exception(f"Unknown MXA generation {gen_towers & 0x0F} detected!")

    towers = (gen_towers & 0xF0) >> 4
    mpus = int.from_bytes(f.read(1), byteorder='little')
    frequency = int.from_bytes(f.read(2), byteorder='little')
    num_inports = int.from_bytes(f.read(1), "little")
    num_outports = int.from_bytes(f.read(1), "little")
    meta['num_inports'] = num_inports
    meta['num_outports'] = num_outports

    meta['sim_info'] = {'towers': towers, 'frequency': frequency}

    meta['mxa_gen'] = gen
    meta['num_mxas'] = mpus
    inport_info_dict = {}
    outport_info_dict = {}

    # INPORTS
    # ==============================================================
    for i in range(num_inports):
        port_idx_and_status = int.from_bytes(f.read(1), "little")
        # if inport is enabled
        if (port_idx_and_status & 0x0080) == 0x80:
            port_set = int.from_bytes(f.read(1), "little")
            mpu_id = int.from_bytes(f.read(1), "little")
            model_index = int.from_bytes(f.read(1), "little")
            layer_name_leng = int.from_bytes(f.read(2), "little")
            layer_name = str(f.read(layer_name_leng), 'utf-8')
            fmt = int.from_bytes(f.read(1), "little")
            range_en = int.from_bytes(f.read(1), "little")
            range_sh = struct.unpack('<f', bytearray(f.read(4)))[0]
            range_sc = struct.unpack('<f', bytearray(f.read(4)))[0]
            row = int.from_bytes(f.read(2), "little")
            col = int.from_bytes(f.read(2), "little")
            z = int.from_bytes(f.read(2), "little")
            ch = int.from_bytes(f.read(4), "little")

            # set the data dict
            port = port_idx_and_status & 0x007F
            inport_info_dict[port] = {"active": True}
            inport_info_dict[port]['mxa_id'] = mpu_id
            inport_info_dict[port]['model_index'] = model_index
            inport_info_dict[port]['layer_name'] = layer_name
            inport_info_dict[port]['set'] = port_set
            if fmt == 0:
                inport_info_dict[port]['data_type'] = "float"
                inport_info_dict[port]['packing_format'] = "gbf80"
            elif fmt == 1:
                inport_info_dict[port]['data_type'] = "rgb565"
                inport_info_dict[port]['packing_format'] = "rgb565"
            elif fmt == 2:
                inport_info_dict[port]['data_type'] = "uint8"
                inport_info_dict[port]['packing_format'] = "rgb888"
            elif fmt == 3:
                inport_info_dict[port]['data_type'] = "yuv422"
                inport_info_dict[port]['packing_format'] = "yuv422"
            elif fmt == 4:
                inport_info_dict[port]['data_type'] = "float"
                inport_info_dict[port]['packing_format'] = "bf16" # actually BF16
            elif fmt == 5:
                inport_info_dict[port]['data_type'] = "float"
                inport_info_dict[port]['packing_format'] = "fp32" # actually FP32
            elif fmt == 6:
                inport_info_dict[port]['data_type'] = "float"
                inport_info_dict[port]['packing_format'] = "gbf80_row"
            else:
                inport_info_dict[port]['data_type'] = "unknown"
                inport_info_dict[port]['packing_format'] = "unknown: " + str(fmt)
            # range info
            if range_en == 1:
                inport_info_dict[port]['data_range_enabled'] = True
            else:
                inport_info_dict[port]['data_range_enabled'] = False
            inport_info_dict[port]['data_range_shift'] = range_sh
            inport_info_dict[port]['data_range_scale'] = range_sc
            # shapes
            inport_info_dict[port]['shape'] = [row, col, z, ch]
        else:
            # inactive port
            port = port_idx_and_status
            inport_info_dict[port] = {"active": False, "set": 0, "mxa_id": -1,
                    "model_index": -1, "layer_name": "", "format": "float",
                    "data_range_enabled": False, "data_range_shift": 0, "data_range_scale": 0,
                    "shape": [0, 0, 0, 0] }

    # OUTPORTS
    # ==============================================================
    for i in range(num_outports):
        port_idx_and_status = int.from_bytes(f.read(1), "little")
        if (port_idx_and_status & 0x0080) == 0x80:
            port_set = int.from_bytes(f.read(1), "little")
            mpu_id = int.from_bytes(f.read(1), "little")
            model_index = int.from_bytes(f.read(1), "little")
            layer_name_leng = int.from_bytes(f.read(2), "little")
            layer_name = str(f.read(layer_name_leng), 'utf-8')
            fmt = int.from_bytes(f.read(1), "little")
            row = int.from_bytes(f.read(2), "little")
            col = int.from_bytes(f.read(2), "little")
            z = int.from_bytes(f.read(2), "little")
            ch = int.from_bytes(f.read(4), "little")

            hpoc_eni = int.from_bytes(f.read(1), "little")
            # hpoc en?
            if hpoc_eni == 1:
                hpoc_en = True
                # hpoc_fm_shape
                hpoc_row = int.from_bytes(f.read(2), "little")
                hpoc_col = int.from_bytes(f.read(2), "little")
                hpoc_z = int.from_bytes(f.read(2), "little")
                hpoc_ch = int.from_bytes(f.read(4), "little")
                hpoc_fm_shape = [hpoc_row, hpoc_col, hpoc_z, hpoc_ch]
                # hpoc list length + data
                hpoc_ch_list_len = int.from_bytes(f.read(2), "little")
                hpoc_ch_list = []
                for _ in range(hpoc_ch_list_len):
                    hpoc_ch_list.append(int.from_bytes(f.read(2), "little"))
            else:
                # hpoc disabled!
                hpoc_en = False
                hpoc_ch_list_len = 0
                hpoc_ch_list = []
                hpoc_fm_shape = []

            # port index + status
            port = port_idx_and_status & 0x007F
            outport_info_dict[port] = {"active": True}
            outport_info_dict[port]['mxa_id'] = mpu_id
            outport_info_dict[port]['model_index'] = model_index
            outport_info_dict[port]['layer_name'] = layer_name
            # port set
            outport_info_dict[port]['set'] = port_set
            # data format
            if fmt == 0:
                outport_info_dict[port]['data_type'] = "float"
                outport_info_dict[port]['packing_format'] = "gbf80"
            elif fmt == 4:
                outport_info_dict[port]['data_type'] = "float"
                outport_info_dict[port]['packing_format'] = "bf16"
            elif fmt == 5:
                outport_info_dict[port]['data_type'] = "float"
                outport_info_dict[port]['packing_format'] = "fp32"
            elif fmt == 6:
                outport_info_dict[port]['data_type'] = "float"
                outport_info_dict[port]['packing_format'] = "gbf80_row"
            else:
                outport_info_dict[port]['data_type'] = "unknown"
                outport_info_dict[port]['packing_format'] = "unknown: " + str(fmt)
            # shapes
            outport_info_dict[port]['shape'] = [row, col, z, ch]

            # hpoc info
            outport_info_dict[port]['hpoc_enabled'] = hpoc_en
            outport_info_dict[port]['hpoc_list'] = hpoc_ch_list
            outport_info_dict[port]['hpoc_fm_shape'] = hpoc_fm_shape
        else:
            # inactive port
            port = port_idx_and_status
            outport_info_dict[port] = {"active": False, "set": 0, "mxa_id": -1,
                    "model_index": -1, "layer_name": "", "format": "float",
                    "shape": [0, 0, 0, 0], "hpoc_enabled": False, "hpoc_list": [],
                    "hpoc_fm_shape": [0, 0, 0, 0] }


    meta['input_ports'] = inport_info_dict
    meta['output_ports'] = outport_info_dict

    # return to start and skip to hw dfp
    f.seek(0)
    f.seek(16, 1)
    f.seek(total_sim_bytes, 1)
    hw_data_size = int.from_bytes(f.read(8), "little")
    meta['hardware_dfp_size'] = float(hw_data_size / 1000000)

    return meta

def __decode_v6(f):

    dat = MxPackDecode(bytearray(f.read()))

    meta = {"dfp_version": "6"}


    # metadata section
    #####################################################################################
    if dat["sim_dfp"]["enabled"]:
        meta["simulator_dfp_size"] = float( int(len(dat["sim_dfp"]["data"])) / 1000000 )
    else:
        meta["simulator_dfp_size"] = 0

    meta["hardware_dfp_size"] = float( int(len(dat["hw_dfp"])) / 1000000 )

    meta["compile_time"] = dat["compile_timestamp"]
    meta["models"] = dat["models"]
    meta["compiler_version"] = dat["compiler_version"]
    meta["compiler_args"] = dat["compiler_args"]

    meta["num_inports"] = dat["num_inports"]
    meta["num_outports"] = dat["num_outports"]

    meta["sim_info"] = {"towers": dat["sim_meta"]["towers"],
                        "frequency": dat["freq"] }

    if dat["sim_meta"]["intgen"] == 4:
        meta["mxa_gen"] = "Cascade+"
    elif dat["sim_meta"]["intgen"] == 3:
        meta["mxa_gen"] = "Cascade"
    elif dat["sim_meta"]["intgen"] == 5:
        meta["mxa_gen"] = "Detroit"
    elif dat["sim_meta"]["intgen"] == 2:
        meta["mxa_gen"] = "Barton"
    else:
        raise UtilityError(message=f"Unknown MXA generation {dat['sim_meta']['intgen']} detected!")

    meta["num_mxas"] = dat["sim_meta"]["num_mpus"]

    # port info section
    #####################################################################################

    inport_info_dict = {}
    for p in dat["inport_info"]:

        if p["active"]:
            inport_info_dict[p["port"]] = {
                    "active": True,
                    "set": p["port_set"],
                    "mxa_id": p["mpu_id"],
                    "model_index": p["model_index"],
                    "layer_name": p["layer_name"],
                    "data_type": "float",   # FIXME: we disabled RGB888
                    "data_range_enabled": p["range_convert"]["enabled"],
                    "data_range_shift": p["range_convert"].get("shift", float(0)),
                    "data_range_scale": p["range_convert"].get("scale", float(0)),
                    "packing_format": p["packing_format"]["name"],
                    "shape": p["mxa_shape"]
                }
        else:
            inport_info_dict[p["port"]] = {"active": False, "set": 0, "mxa_id": -1,
                            "model_index": -1, "layer_name": "", "data_type": "float",
                                            "data_range_enabled": False, "data_range_shift": 0, "data_range_scale": 0, "packing_format": "fp32",
                            "shape": [0, 0, 0, 0] }

    meta['input_ports'] = inport_info_dict


    outport_info_dict = {}
    for p in dat["outport_info"]:

        if p["active"]:
            outport_info_dict[p["port"]] = {
                    "active": True,
                    "set": p["port_set"],
                    "mxa_id": p["mpu_id"],
                    "model_index": p["model_index"],
                    "layer_name": p["layer_name"],
                    "data_type": "float",
                    "packing_format": p["packing_format"]["name"],
                    "shape": p["mxa_shape"],
                    "hpoc_enabled": p["hpoc"]["enabled"],
                    "hpoc_list": p["hpoc"].get("channels", []),
                    "hpoc_fm_shape": p["hpoc"].get("shape", [0,0,0,0])
                    }
        else:
            outport_info_dict[p["port"]] = {"active": False, "set": 0, "mxa_id": -1,
                    "model_index": -1, "layer_name": "", "data_type": "float", "packing_format": "fp32",
                    "shape": [0, 0, 0, 0], "hpoc_enabled": False, "hpoc_list": [],
                    "hpoc_fm_shape": [0, 0, 0, 0] }

    meta['output_ports'] = outport_info_dict

    return meta

###############################################################################
###############################################################################
###############################################################################

def main():
    parser = argparse.ArgumentParser(description = "\033[34mMemryX DFP Inspector\033[0m")
    parser.add_argument("filename",
                            type = str,
                            action = "store",
                            help = "path to .dfp file to inspect")

    args = parser.parse_args()

    ignoreddata = dfp_inspect(args.filename, printout=True)


if __name__=="__main__":
    main()
